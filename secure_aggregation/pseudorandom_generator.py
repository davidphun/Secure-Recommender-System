from Crypto.Cipher import AES
import numpy as np
import time

class PNG_AES_CTR:
    '''
        Secure Pseudorandom Generator, which takes an arbitrary seed of 16 bytes as the key of AES algorithm
        and makes use of CTR to generate 128-bit random vector via the encryption process
    '''
    def __init__(self, secret_seed):
        self.secret_seed = secret_seed # Secret seed is an integer value
        # Secret seed in byte format
        self.secret_seed_bytes = self.secret_seed.to_bytes(16, 'little')
        self.aes_ctr = AES.new(self.secret_seed_bytes, AES.MODE_CTR, nonce=b'\x00')
        # This is the initialization of parameters used in ziggurat method for generating samples in Gauss dist
        self.ziggurat_positions, self.ziggurat_acceptance_thresholds, self.ziggurat_weights = \
            self.initialize_ziggurat_decision_params()
    
    def int_from_byte(self, bytes):
        '''
            Convert a sequence of bytes into an integer
        '''
        int_val = 0
        i = 0
        while i < len(bytes):
            int_val += bytes[i] << (8 * i)
            i += 1
        return int_val

    def generate_random_bytes(self, n_bytes):
        '''
            Randomly generate a sequence of bytes whose size is n_bytes
        '''
        data = b'\x00' * n_bytes # Create a n_bytes block of data, where all bits are 0
        # Encrypt the data using AES CTR to generate the corresponding randomized block of data,
        # whose size is n_bytes
        cipher_bytes = self.aes_ctr.encrypt(data)
        return cipher_bytes


    def random(self, randomized_bytes=None):
        ''' 
            Generate a random number in [0, 1)
        '''
        if randomized_bytes is None:
            randomized_bytes = self.generate_random_bytes(7)
        assert len(randomized_bytes) == 7, 'Number of bytes must be 7!'
        normalizing_const = 2 ** 53 # Maximum value of a 53-bit integer
        randomized_int = self.int_from_byte(randomized_bytes)
        # Float number is 53 bits => If the given data is 7 bytes (56 bits)
        # Trim down the rightmost 3 bits to get the random sequence of 53 bits
        trimmed_randomized_int = randomized_int >> 3 
        return trimmed_randomized_int / normalizing_const
    
    def random_std_normal(self, shape=1):
        '''
            Generate a random number from N(0, 1) using Box-Muller method

            Parameters
            ----------

            shape: Size of the output, i.e., the number of random variables one needs to generate

            Return
            ------

            rand_vars: A vector of random variables generated by N(0, 1), 
                        whose size is determined by shape
        '''
        start_t = time.time()
        n_elements = np.prod([i for i in shape]) if type(shape) == tuple else shape
        rand_vars = np.zeros(n_elements)
        n_even_elements = n_elements - 1 if n_elements % 2 != 0 else n_elements
        i = 0
        while n_even_elements - i > 0:
            U1 = self.random()
            U2 = self.random()
            Z1 = ((-2 * np.log(U1)) ** (0.5)) * np.cos(2 * np.pi * U2)
            Z2 = ((-2 * np.log(U1)) ** (0.5)) * np.sin(2 * np.pi * U2)
            rand_vars[i] = Z1
            rand_vars[i+1] = Z2
            i += 2
        if n_even_elements < n_elements:
            U1 = self.random()
            U2 = self.random()
            Z = ((-2 * np.log(U1)) ** (0.5)) * np.cos(2 * np.pi * U2)
            rand_vars[-1] = Z
        rand_vars = rand_vars.reshape(shape) if type(shape) == tuple else rand_vars
        return rand_vars
    
    def initialize_ziggurat_decision_params(self):
        '''
            Calculate the rightmost position of each rectangle according to the # of specified rectangles and 
            the common area of any region
            Then compute the acceptance threshold and the weight to convert random integer to random number ~ N(0, 1) for each region...
        '''
        n_ziggurats = 256 # Number of rectangles to approximate the distribution
        v = .00492867323399 # Area of each region
        r = 3.6541528853610088 # Cutoff point
        positions = np.zeros(n_ziggurats)
        positions[n_ziggurats-1] = r
        inv_f_y = lambda y: np.sqrt(-2 * np.log(y)) # Inverse kernel of Std Gaussian distribution
        f_x = lambda x: np.exp(-(x**2) / 2) # Kernel of Std Gaussian distribution
        for i in range(n_ziggurats-2, 0, -1):
            positions[i] = inv_f_y(v / positions[i+1] + f_x(positions[i+1]))
        acceptance_thresholds = np.zeros(n_ziggurats) # Thresholds to decide whether should a point will be blindly accepted or not
        weights = np.zeros(n_ziggurats) # Random integer multiplies with weight should result in a point generated from N(0, 1)
        for i in range(1, n_ziggurats):
            acceptance_thresholds[i] = pow(2, 32) * (positions[i-1] / positions[i])
            weights[i] = pow(2, -32) * positions[i]
        acceptance_thresholds[0] = pow(2, 32) * r * f_x(r) / v # Acceptance threshold for the base region
        # Weight to generate a point in the base region
        # Firstly, generate a number z within [0, v]
        # Secondly, find x via x = z / f_x(r) (Assumming the height of the rectangle is always f_x(r))
        weights[0] = pow(2, -32) * v / f_x(r) 
        return positions, acceptance_thresholds, weights

    def random_std_normal_ziggurat(self, shape=1):
        '''
            Generate a random number from N(0, 1) using Ziggurat method

            Parameters
            ----------

            shape: Size of the output, i.e., the number of random variables one needs to generate

            Return
            ------

            rand_vars: A vector of random variables generated by N(0, 1), 
                        whose size is determined by shape
        '''
        f_x = lambda x: np.exp(-(x**2) / 2) # Kernel of Std Gaussian distribution
        n_elements = np.prod(shape) if type(shape) == tuple else shape
        rand_vars = np.zeros(n_elements)
        for e in range(n_elements):
            accepted = False
            while not accepted:
                # 4 bytes for random integer, 1 more byte for random region, 
                # and 1 more byte for sign of the integer (actually 1 bit is sufficient but the PNG generate random bytes...)
                rand_bytes = self.generate_random_bytes(6)
                rand_region = rand_bytes[0]
                rand_sign = rand_bytes[1] >> 7 # Get 1 random bit to determine the sign of the generated point
                rand_int = self.int_from_byte(rand_bytes[2:])
                rand_x = rand_int * self.ziggurat_weights[rand_region]
                if rand_int < self.ziggurat_acceptance_thresholds[rand_region]:
                    rand_vars[e] = ((2 * rand_sign) - 1) * rand_x
                    accepted = True
                else:
                    rand_y = rand_x * f_x(self.ziggurat_positions[rand_region - 1]) - f_x(self.ziggurat_positions[rand_region])
                    if rand_y < f_x(rand_x):
                        rand_vars[e] = ((2 * rand_sign) - 1) * rand_x
                        accepted = True
        rand_vars = rand_vars.reshape(shape) if type(shape) == tuple else rand_vars
        return rand_vars





# png1 = PNG_AES_CTR(123)
# start_t = time.time()
# #print(png1.random_std_normal(20*10000))
# rvs = png1.random_std_normal_ziggurat(20*10000)
# print('Time: {}'.format(time.time() - start_t))

# import matplotlib.pyplot as plt
# plt.hist(rvs)
# plt.show()